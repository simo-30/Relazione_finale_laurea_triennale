\documentclass[Lau, oneside]{sapthesis}%remove "english" for a thesis written in Italian
%Bachelor's (laurea triennale) thesis : Lau 
%Master's (laurea specialistica) thesis: LaM 
%PhD's thesis: PhD 
\usepackage[italian]{babel} %use this package for a thesis written in Italian
\usepackage[utf8]{inputenx}
\usepackage{indentfirst}
\usepackage{microtype}
%\usepackage{chemformula}
%\usepackage{setspace}
%\usepackage{yfonts,color}
%\usepackage{siunitx}
%\usepackage{comment}
%\usepackage{multirow}
%\usepackage{varioref}
%\usepackage[bottom]{footmisc}
%\usepackage{wrapfig}
%\usepackage{float}
%\usepackage{type1cm}
\usepackage{lettrine}
\linespread{0.9}
%\usepackage{chngcntr}
\usepackage[nottoc, notlof, notlot]{tocbibind}
%\onehalfspacing
%\counterwithout{footnote}{chapter}
\usepackage{hyperref}
\hypersetup{
			hyperfootnotes=true,			
			bookmarks=true,			
			colorlinks=true,
			linkcolor=red,
                        linktoc=page,
			anchorcolor=black,
			citecolor=red,
			urlcolor=blue,
			pdftitle={A sample Bachelor's thesis for Sapienza Università di Roma},
			pdfauthor={FirstName LastName},
			pdfkeywords={thesis, sapienza, roma, university}
}

\title{Scheduler dei processi di un sistema operativo, confronto ed analisi di varie politiche}
\author{Simone Trenta}
\IDnumber{1724141}
\course[]{Ingegneria informatica ed automatica}
\courseorganizer{Facolt\`a di Ingegneria dell'informazione, informatica e statistica}
\submitdate{2020/2021}
\copyyear{2020}
\advisor{Prof. Giorgio Grisetti}
\authoremail{trenta.1724141@studenti.uniroma1.it}
\examdate{22 September 2015}
\examiner{Prof. ...} \examiner{Prof. ...} \examiner{Prof. ...}  \examiner{Prof. ...}  \examiner{Prof. ...} \examiner{Prof. ...}  \examiner{Prof. ...} 

%we refer to http://ctan.mirrorcatalogs.com/macros/latex/contrib/sapthesis/sapthesis-doc.pdf for an exhaustive description of the sapthesis documentclass.


\begin{document}

\frontmatter
\maketitle

\begin{abstract}
Tramite un progetto di simulazione di uno scheduler di un sistema operativo, si analizzano le varie politiche di scheduling fra le più comuni, ossia first came first served (FCFS), round robin (RR), shortest job first (SJF) e shortest remaining job first (SRJF).
\end{abstract}

\tableofcontents

\mainmatter
\chapter{Introduzione}
\lettrine[lines=2, findent=3pt, nindent=0pt]{I}{}n un sistema operativo la gestione delle richieste di risorse da parte dei processi è demandata allo scheduler.
Questa funzione di un sistema operativo è pressoché essenziale, senza la quale le risorse disponibili non potrebbero essere riservate e utilizzate in modo efficiente.

\bigskip
Nel \hyperref[chap:1]{Capitolo~\ref*{chap:1}}

\bigskip
Nel \hyperref[chap:2]{Capitolo~\ref*{chap:2}} 

\bigskip
Nel \hyperref[chap:3]{Capitolo~\ref{chap:3}} 

\chapter{Lo scheduler in un sistema operativo}
\label{chap:1} 
\section{La sua utilità}
\label{sec:utilita}
Un odierno sistema operativo è composto da molteplici parti, una di esse è lo scheduler dei processi.
Questi ultimi sono parte costituente del sistema operativo, sono la parte esecutiva di esso.
Per meglio capire, i processi richiedono delle risorse del calcolatore, che siano risorse unicamente della CPU oppure di risorse di I/O.
Qualunque tipo di risorsa richiedano, spesso non è immediatamente disponibile, essendo limitate in un calcolatore.
Per cui è necessaria la presenza di un elemento che permetta al dispositivo di gestire le proprie risorse, tale elemento è per l'appunto lo scheduler.
Vedendo il problema da parte dei processi, problema che è la possibilità di usare una risorsa o meno, si crea la necessità di dare delle priorità per poterne usufruire.
Andando quindi a dare origine a tali priorità si producono di conseguenza delle politiche per poterle mettere in atto.

\section{Politiche di scheduling}
\label{sec:politiche}
Le politiche di scheduling sono degli algoritmi, che permettono quindi di riservare le risorse del calcolatore in un certo modo.
Ognuna di esse ha, come ogni cosa, dei vantaggi e degli svantaggi.
Tale prospettiva non permette di rendere efficiente una unica politica per ogni tipo di calcolatore, ma sarà necessario dotare ogni sistema operativo con l'algoritmo più adatto.
Alcuni parametri che vengono persi in considerazione per valutare l'efficienza di un algoritmo sono:
\begin{itemize}
\item Utilizzo della CPU
\item Throughput del sistema
\item Tempo di attesa di un processo
\item Turnaround di un processo
\item tempo di risposta di un processo
\end{itemize}
Fra questi non tutti potranno essere ottimizzati allo stesso tempo, in particolare nei sistemi batch si massimizza throughput e minimizza il turnaround, mentre nei sistemi interattivi si minimizza il tempo medio di risposta ed il tempo di attesa.
I parametri considerati nel progetto implementato sono il tempo di attesa e il tempo di completamento di un processo.
Quest'ultimo da considerarsi come il tempo totale che ogni processo ha impiegato per terminare, per cui partendo sempre dallo stesso valore per il tempo massimo iniziale, se il tempo di completamento sarà elevato vorrà dire che il processo ha impiegato molto per concludersi, rimanendo talvolta in attesa.

\subsection{First came first served}
\label{subsec:fcfs}
L'algoritmo \textit{first came first served}, forse, è il più semplice da capire, e da implementare.
Come dice il nome stesso esso non ha una particolare complessità, semplicemente quando un processo arriva, se è disponibile la risorsa, quindi un core della cpu, esso viene messo in running.
Altrimenti viene messo in una coda di waiting, dalla quale vengono presi i processi da mettere in running, prima di considerare i nuovi processi in arrivo.
In questa politica può risultare che un processo debba attendere la terminazione di un altro prima di poter entrare in running.
Per cui può risultare che dovrà attendere molto in stato di waiting, nascendo quindi il problema di attesa lunghe se le durate dei processi sono elevate.

\subsection{Round robin}
\label{subsec:rr}
L'algoritmo \textit{round robin} è una successiva perfezione del precedente fcfs (first came first served).
Anche in questo caso è presente una coda dei processi che sono arrivati.
Se è disponibile la risorsa richiesta dal processo in arrivo, gli viene riservata e tale processo può sfruttarla, altrimenti viene inserito nella coda di attesa.
Un processo in running, però, non ha la risorsa riservata fino a quando lo necessita, ma in questo caso è presente un clock, che inizia a scorre appena il processo entra in running.
Terminato il clock, la risorsa viene liberata dal processo.
Esso viene inserito nella coda dei processi in attesa, e da essa viene preso il primo processo per destinargli la risorsa appena liberatesi.
Il problema di questo algoritmo è scegliere un valore ottimale per il clock, se troppo elevato si tenderà ad avere un approccio simile a fcfs, se non uguale, se troppo breve i processi non riusciranno a sfruttare la risorsa richiesta che dovranno liberarla.

\subsection{Shortest job first}
\label{subsec:sjf}
L'algoritmo \textit{shortest job first} ordina i processi da mettere in running, ovviamente se c'è disponibilità di risorsa, in base a quanto tempo essi la richiedono, dal più breve al più lungo.
Anche in questo algoritmo un processo entrato in running termina completamente il suo job prima di terminare.
Se la risorsa non è disponibile, il processo viene inserito in una coda, il cui ordinamento è basato sulla durata del job.
Inoltre tutti i processi da mettere in running vengono presi da questa coda a cui si aggiungo i processi che arrivano in un determinato istante.
In questo algoritmo risulterà che i processi con la richiesta minore di risorsa saranno schedulati e termineranno per primi.
Il tempo medio di attesa si riduce, però il problema principale di questa politica nella realtà è riuscire a predire, con sufficiente accuratezza, quanto un processo occuperà una risorsa.
Nel caso del simulatore sviluppato ciò non è necessario, poiché ogni processo che arriva dichiara per quanto tempo occuperà la risorsa.
Al contrario, realisticamente, si utilizza la seguente formula per predire l'utilizzo successivo della cpu:
\begin{equation}\label{predizione}
   \hat{b}_{t+1} = \alpha b_t + (1 - \alpha) \hat{b}_t
\end{equation}
In cui si ha:
\begin{equation}
  \hat{b}_{t+1}
\end{equation}
è la predizione al tempo t+1;
\begin{equation}
    \alpha
\end{equation}
è il coefficiente di decadimento;
\begin{equation}
    b_t
\end{equation}
è la misura avvenuta al tempo t;
\begin{equation}
    \hat{b}_t
\end{equation}
è la predizione al tempo t.

\subsection{Shortest remaining job first}
\label{subsec:srjf}
L'algoritmo \textit{shortest remaining job first} è simile al precedente sjf.
Però in questo caso ad ogni ciclo di clock della cpu, i processi in running vengono confrontati con tutti quelli in waiting e quelli appena arrivati.
I processi, sempre in base alla disponibilità della risorsa, vengono messi in running, o ci rimangono, in ordine in base alla durata del job, dal più piccolo al più grande.
Anche in questo caso il problema principale è riuscire a predire la durata della richiesta della risorsa, e si utilizza la formula \eqref{predizione}.

\chapter{MOONS}
\label{chap:2}
\section{The Very Large Telescope}
Property of the European Southern Observatory...

\section{The Multi-Object Optical and Near-infrared Spectrograph}
\label{sec:moons}

The \textit{Multi-Object Optical and Near-infrared Spectrograph} is a future generation MOS instrument for the VLT. 

\chapter{Conclusions}
\label{chap:3}
The grasping power of the mirror..

\backmatter
\phantomsection
\begin{thebibliography}{17}

\bibitem{ref:vph}
Blanche P.A., Gailly P., et al., “\textit{Volume phase holographic gratings: large size and high diffraction efficiency}“, Optical Engineering, Vol. 43, No.11, November 2004

\bibitem{ref:science}
Cirasuolo M., et al., \textit{"MOONS Science Report"}, MOONS Document Number: VLT-TRE-MON-14620-0001, Issue: $1.0$, $31^{\textup{st}}$ January $2013$

\bibitem{ref:eso}
European Southern Observatory, \url{http://www.eso.org}

\end{thebibliography}

\end{document}